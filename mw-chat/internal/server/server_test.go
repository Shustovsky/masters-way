package server

import (
	"context"
	"mwchat/internal/auth"
	"mwchat/internal/config"
	db "mwchat/internal/db/sqlc"
	"mwchat/internal/openapi"
	"mwchat/internal/schemas"
	"mwchat/pkg/utils"
	"net/http"
	"testing"

	openapiChat "mwchat/apiAutogenerated/chat"

	"github.com/samber/lo"
	"github.com/stretchr/testify/assert"
)

func TestGetRoomById(t *testing.T) {
	newConfig, err := config.LoadConfig("../../")
	if err != nil {
		t.Fatalf("Failed to load config: %v", err)
	}

	chatApi := openapi.MakeChatAPIClient(&newConfig)
	_, err = chatApi.DevAPI.DevResetDbGet(context.Background()).Execute()
	if err != nil {
		t.Fatalf("Failed to reset db: %v", err)
	}

	currentUserID := "d2cb5e1b-44df-48d3-b7a1-34f3d7a5b7e2"
	userID := "3d922e8a-5d58-4b82-9a3d-83e2e73b3f91"
	roomID := "78bdf878-3b83-4f97-8d2e-928c132a10cd"

	t.Run("should return private room by room id with messages and users", func(t *testing.T) {
		token, err := auth.GenerateTestJWT(newConfig.SecretSessionKey, currentUserID)
		if err != nil {
			t.Fatalf("Failed to generate JWT: %v", err)
		}

		ctx := context.WithValue(context.Background(), auth.ContextKeyAuthorization, "Bearer "+token)
		getRoomByIdResponse, response, err := chatApi.RoomAPI.GetRoomById(ctx, roomID).Execute()

		expectedData := schemas.RoomPopulatedResponse{
			RoomID:    roomID,
			Name:      nil,
			RoomType:  "private",
			IsBlocked: false,
			Users: []schemas.UserResponse{
				{
					UserID: currentUserID,
					Role:   "regular",
				},
				{
					UserID: userID,
					Role:   "regular",
				},
			},
			Messages: []schemas.MessageResponse{
				{
					MessageID: "7939af01-e785-445d-b79d-70a433979c7b",
					OwnerID:   currentUserID,
					Message:   "Test message 1",
					Readers:   []schemas.MessageReader{},
				},
				{
					MessageID: "91be5d99-eddf-4949-bf15-b4cee3989fa6",
					OwnerID:   userID,
					Message:   "Test message 2",
					Readers: []schemas.MessageReader{
						{
							UserID:   currentUserID,
							ReadDate: "2024-08-09T01:05:00.000Z",
						},
					},
				},
				{
					MessageID: "88a6d503-a03b-412c-bfab-06649e49d62d",
					OwnerID:   currentUserID,
					Message:   "Test message 3",
					Readers:   []schemas.MessageReader{},
				},
				{
					MessageID: "6cea59ef-f0d4-4d8c-aa12-e48a746c93d0",
					OwnerID:   userID,
					Message:   "Test message 4",
					Readers: []schemas.MessageReader{
						{
							UserID:   currentUserID,
							ReadDate: "2024-08-09T01:05:00.000Z",
						},
					},
				},
			},
		}

		assert.Equal(t, http.StatusOK, response.StatusCode)
		assert.Equal(t, expectedData, ConvertOpenapiRoomPopulatedResponse(getRoomByIdResponse))
	})
}

func TestGetChatPreview(t *testing.T) {
	newConfig, err := config.LoadConfig("../../")
	if err != nil {
		t.Fatalf("Failed to load config: %v", err)
	}

	chatApi := openapi.MakeChatAPIClient(&newConfig)
	_, err = chatApi.DevAPI.DevResetDbGet(context.Background()).Execute()
	if err != nil {
		t.Fatalf("Failed to reset db: %v", err)
	}

	currentUserID := "d2cb5e1b-44df-48d3-b7a1-34f3d7a5b7e2"

	t.Run("should return chat preview with correct unread messages amount", func(t *testing.T) {
		token, err := auth.GenerateTestJWT(newConfig.SecretSessionKey, currentUserID)
		if err != nil {
			t.Fatalf("Failed to generate JWT: %v", err)
		}

		ctx := context.WithValue(context.Background(), auth.ContextKeyAuthorization, "Bearer "+token)
		getChatPreviewResponse, response, err := chatApi.RoomAPI.GetChatPreview(ctx).Execute()
		if err != nil {
			t.Fatalf("Failed to get chat preview: %v", err)
		}

		expectedData := schemas.GetChatPreviewResponse{
			UnreadMessagesAmount: 3,
		}

		assert.Equal(t, http.StatusOK, response.StatusCode)
		assert.Equal(t, expectedData.UnreadMessagesAmount, int(getChatPreviewResponse.UnreadMessagesAmount))
	})
}

func TestGetRooms(t *testing.T) {
	newConfig, err := config.LoadConfig("../../")
	if err != nil {
		t.Fatalf("Failed to load config: %v", err)
	}

	chatApi := openapi.MakeChatAPIClient(&newConfig)
	_, err = chatApi.DevAPI.DevResetDbGet(context.Background()).Execute()
	if err != nil {
		t.Fatalf("Failed to reset db: %v", err)
	}

	roomCreatorID := "d63d2f89-6412-4324-8587-7061bf02dca4"

	user1ID := "c31384a6-b811-4a1f-befa-95dd53e3f4b9"
	room1ID := "e57fc491-69f7-4b30-9979-78879c8873bf"

	user2ID := "5a31e3cb-7e9a-41e5-9a3b-1f1e5d6b7c3e"
	room2ID := "897f4a0f-fe31-4036-8358-f89a19c9bda6"

	user3ID := "8a3d1fe1-42da-499a-bf64-248297fd670a"
	room3ID := "85f610df-9f86-4c55-8ee1-02485d42defb"

	t.Run("should return list of private rooms successfully", func(t *testing.T) {

		token, err := auth.GenerateTestJWT(newConfig.SecretSessionKey, roomCreatorID)
		if err != nil {
			t.Fatalf("Failed to generate JWT: %v", err)
		}

		ctx := context.WithValue(context.Background(), auth.ContextKeyAuthorization, "Bearer "+token)
		getRoomsResponse, response, err := chatApi.RoomAPI.GetRooms(ctx, "private").Execute()
		if err != nil {
			t.Fatalf("Failed to get chat preview: %v", err)
		}

		expectedData := schemas.GetRoomsResponse{
			Size: 3,
			Rooms: []schemas.RoomPreviewResponse{
				{
					RoomID:    room1ID,
					Name:      nil,
					RoomType:  string(db.RoomTypePrivate),
					IsBlocked: false,
					Users: []schemas.UserResponse{
						{
							UserID: roomCreatorID,
							Role:   "regular",
						},
						{
							UserID: user1ID,
							Role:   "regular",
						},
					},
				},
				{
					RoomID:    room2ID,
					Name:      nil,
					RoomType:  string(db.RoomTypePrivate),
					IsBlocked: false,
					Users: []schemas.UserResponse{
						{
							UserID: roomCreatorID,
							Role:   "regular",
						},
						{
							UserID: user2ID,
							Role:   "regular",
						},
					},
				},
				{
					RoomID:    room3ID,
					Name:      nil,
					RoomType:  string(db.RoomTypePrivate),
					IsBlocked: false,
					Users: []schemas.UserResponse{
						{
							UserID: roomCreatorID,
							Role:   "regular",
						},
						{
							UserID: user3ID,
							Role:   "regular",
						},
					},
				},
			},
		}

		assert.Equal(t, http.StatusOK, response.StatusCode)
		assert.Equal(t, expectedData.Size, int(getRoomsResponse.Size))
		assert.ElementsMatch(t, expectedData.Rooms, ConvertOpenapiRoomPreviewResponse(getRoomsResponse.Rooms))
	})
}

func TestCreateRoom(t *testing.T) {
	newConfig, err := config.LoadConfig("../../")
	if err != nil {
		t.Fatalf("Failed to load config: %v", err)
	}

	chatApi := openapi.MakeChatAPIClient(&newConfig)
	_, err = chatApi.DevAPI.DevResetDbGet(context.Background()).Execute()
	if err != nil {
		t.Fatalf("Failed to reset db: %v", err)
	}

	roomCreatorID := "5bee7465-220d-40e7-82d7-b9b607fff21c"
	userID := "f4cbdb32-0fc0-4704-a6d9-9cf357e5cd3e"

	token, err := auth.GenerateTestJWT(newConfig.SecretSessionKey, roomCreatorID)
	if err != nil {
		t.Fatalf("Failed to generate JWT: %v", err)
	}

	var userIDNullableString = openapiChat.NullableString{}
	userIDNullableString.Set(&userID)

	request := openapiChat.SchemasCreateRoomPayload{
		Name:     openapiChat.NullableString{},
		RoomType: "private",
		UserId:   userIDNullableString,
	}

	t.Run("should create a private room and return it successfully", func(t *testing.T) {
		ctx := context.WithValue(context.Background(), auth.ContextKeyAuthorization, "Bearer "+token)
		createRoomResponse, response, err := chatApi.RoomAPI.CreateRoom(ctx).Request(request).Execute()
		if err != nil {
			t.Fatalf("Failed to get chat preview: %v", err)
		}

		expectedData := schemas.RoomPopulatedResponse{
			Users: []schemas.UserResponse{
				{
					UserID: roomCreatorID,
					Role:   "regular",
				},
				{
					UserID: userID,
					Role:   "regular",
				},
			},
			Name:      nil,
			Messages:  []schemas.MessageResponse{},
			IsBlocked: false,
		}

		assert.Equal(t, http.StatusOK, response.StatusCode)

		convertedCreateRoomResponse := ConvertOpenapiRoomPopulatedResponse(createRoomResponse)

		assert.Equal(t, expectedData.Users, convertedCreateRoomResponse.Users)
		assert.Equal(t, expectedData.Name, convertedCreateRoomResponse.Name)
		assert.Equal(t, expectedData.Messages, convertedCreateRoomResponse.Messages)
		assert.Equal(t, expectedData.IsBlocked, convertedCreateRoomResponse.IsBlocked)
	})

	t.Run("should return error if private room already exists", func(t *testing.T) {
		ctx := context.WithValue(context.Background(), auth.ContextKeyAuthorization, "Bearer "+token)
		_, response, err := chatApi.RoomAPI.CreateRoom(ctx).Request(request).Execute()
		if err != nil {
			message, extractErr := utils.ExtractErrorMessageFromResponse(response)
			if extractErr != nil {
				t.Fatalf(extractErr.Error())
			}

			assert.Equal(t, http.StatusInternalServerError, response.StatusCode)
			assert.Equal(t, "A private room for these users already exists", message)
		}
	})
}

func TestCreateMessage(t *testing.T) {
	newConfig, err := config.LoadConfig("../../")
	if err != nil {
		t.Fatalf("Failed to load config: %v", err)
	}

	chatApi := openapi.MakeChatAPIClient(&newConfig)
	_, err = chatApi.DevAPI.DevResetDbGet(context.Background()).Execute()
	if err != nil {
		t.Fatalf("Failed to reset db: %v", err)
	}

	currentUserID := "d2cb5e1b-44df-48d3-b7a1-34f3d7a5b7e2"
	userID := "3d922e8a-5d58-4b82-9a3d-83e2e73b3f91"
	roomID := "78bdf878-3b83-4f97-8d2e-928c132a10cd"

	t.Run("should create a message in private room and return it successfully", func(t *testing.T) {
		token, err := auth.GenerateTestJWT(newConfig.SecretSessionKey, currentUserID)
		if err != nil {
			t.Fatalf("Failed to generate JWT: %v", err)
		}

		request := openapiChat.SchemasCreateMessagePayload{
			Message: "roomCreator's message",
		}

		ctx := context.WithValue(context.Background(), auth.ContextKeyAuthorization, "Bearer "+token)
		createMessageResponse, response, err := chatApi.RoomAPI.CreateMessageInRoom(ctx, roomID).Request(request).Execute()
		if err != nil {
			t.Fatalf("Failed to get chat preview: %v", err)
		}

		expectedData := &schemas.CreateMessageResponse{
			Users: []string{currentUserID, userID},
			Message: schemas.MessageResponse{
				OwnerID: currentUserID,
				Message: "roomCreator's message",
				Readers: []schemas.MessageReader{},
			},
		}

		assert.Equal(t, http.StatusOK, response.StatusCode)
		convertedCreateMessageResponse := ConvertOpenapiCreateMessageResponse(createMessageResponse)
		assert.Equal(t, expectedData.Users, convertedCreateMessageResponse.Users)
		assert.Equal(t, expectedData.Message.Message, convertedCreateMessageResponse.Message.Message)
		assert.Equal(t, expectedData.Message.OwnerID, convertedCreateMessageResponse.Message.OwnerID)
		assert.Equal(t, expectedData.Message.Readers, convertedCreateMessageResponse.Message.Readers)
	})
}

func ConvertOpenapiCreateMessageResponse(schemaRoom *openapiChat.SchemasCreateMessageResponse) schemas.CreateMessageResponse {
	readers := lo.Map(schemaRoom.Message.MessageReaders, func(user openapiChat.SchemasMessageReader, _ int) schemas.MessageReader {
		return schemas.MessageReader{
			UserID:   user.UserId,
			ReadDate: user.ReadDate,
		}
	})

	return schemas.CreateMessageResponse{
		Users: schemaRoom.Users,
		Message: schemas.MessageResponse{
			MessageID: schemaRoom.Message.MessageId,
			OwnerID:   schemaRoom.Message.OwnerId,
			Message:   schemaRoom.Message.Message,
			Readers:   readers,
		},
	}
}

func ConvertOpenapiRoomPopulatedResponse(schemaRoom *openapiChat.SchemasRoomPopulatedResponse) schemas.RoomPopulatedResponse {
	users := make([]schemas.UserResponse, len(schemaRoom.Users))
	for i, user := range schemaRoom.Users {
		users[i] = schemas.UserResponse{
			UserID: user.UserId,
			Role:   user.Role,
		}
	}

	messages := make([]schemas.MessageResponse, len(schemaRoom.Messages))
	for i, message := range schemaRoom.Messages {
		readers := make([]schemas.MessageReader, len(message.MessageReaders))
		for j, reader := range message.MessageReaders {
			readers[j] = schemas.MessageReader{
				UserID:   reader.UserId,
				ReadDate: reader.ReadDate,
			}
		}
		messages[i] = schemas.MessageResponse{
			MessageID: message.MessageId,
			OwnerID:   message.OwnerId,
			Message:   message.Message,
			Readers:   readers,
		}
	}

	return schemas.RoomPopulatedResponse{
		RoomID:    schemaRoom.RoomId,
		Name:      schemaRoom.Name.Get(),
		RoomType:  schemaRoom.RoomType,
		IsBlocked: schemaRoom.IsBlocked,
		Users:     users,
		Messages:  messages,
	}
}

func ConvertOpenapiRoomPreviewResponse(schemaRoom []openapiChat.SchemasRoomPreviewResponse) []schemas.RoomPreviewResponse {
	rooms := lo.Map(schemaRoom, func(room openapiChat.SchemasRoomPreviewResponse, _ int) schemas.RoomPreviewResponse {
		users := lo.Map(room.Users, func(user openapiChat.SchemasUserResponse, _ int) schemas.UserResponse {
			return schemas.UserResponse{
				UserID: user.UserId,
				Role:   user.Role,
			}
		})

		return schemas.RoomPreviewResponse{
			RoomID:    room.RoomId,
			Name:      room.Name.Get(),
			RoomType:  room.RoomType,
			IsBlocked: room.IsBlocked,
			Users:     users,
		}
	})
	return rooms
}
